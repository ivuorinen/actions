# yaml-language-server: $schema=https://json.schemastore.org/github-action.json
# permissions:
#   - contents: read  # Required for reading cache contents
---
name: Common Cache
description: 'Standardized caching strategy for all actions'
author: 'Ismo Vuorinen'

branding:
  icon: database
  color: gray-dark

inputs:
  type:
    description: 'Type of cache (npm, composer, go, pip, etc.)'
    required: true
  paths:
    description: 'Paths to cache (comma-separated)'
    required: true
  key-prefix:
    description: 'Custom prefix for cache key'
    required: false
    default: ''
  key-files:
    description: 'Files to hash for cache key (comma-separated)'
    required: false
    default: ''
  restore-keys:
    description: 'Fallback keys for cache restoration'
    required: false
    default: ''
  env-vars:
    description: 'Environment variables to include in cache key'
    required: false
    default: ''

outputs:
  cache-hit:
    description: 'Cache hit indicator'
    value: ${{ steps.cache.outputs.cache-hit }}
  cache-key:
    description: 'Generated cache key'
    value: ${{ steps.prepare.outputs.cache-key }}
  cache-paths:
    description: 'Resolved cache paths'
    value: ${{ steps.prepare.outputs.cache-paths }}

runs:
  using: composite
  steps:
    - id: prepare
      shell: bash
      env:
        RUNNER_OS: ${{ runner.os }}
        CACHE_TYPE: ${{ inputs.type }}
        KEY_PREFIX: ${{ inputs.key-prefix }}
        KEY_FILES: ${{ inputs.key-files }}
        ENV_VARS: ${{ inputs.env-vars }}
        CACHE_PATHS: ${{ inputs.paths }}
      run: |
        set -euo pipefail

        # Generate standardized cache key components
        os_key="$RUNNER_OS"
        type_key="$CACHE_TYPE"
        prefix_key="$KEY_PREFIX"

        # Process file hashes
        # Note: For simple glob patterns, hashFiles() function could be used directly
        # in the cache key. This manual approach is used to support comma-separated
        # file lists with complex cache key construction.
        files_hash=""
        if [ -n "$KEY_FILES" ]; then
          IFS=',' read -ra FILES <<< "$KEY_FILES"
          existing_files=()
          for file in "${FILES[@]}"; do
            # Trim whitespace
            file=$(echo "$file" | xargs)
            if [ -f "$file" ]; then
              existing_files+=("$file")
            fi
          done
          # Hash all files together for better performance
          if [ ${#existing_files[@]} -gt 0 ]; then
            files_hash=$(cat "${existing_files[@]}" | sha256sum | cut -d' ' -f1)
          fi
        fi

        # Process environment variables
        env_hash=""
        if [ -n "$ENV_VARS" ]; then
          IFS=',' read -ra VARS <<< "$ENV_VARS"
          for var in "${VARS[@]}"; do
            if [ -n "${!var}" ]; then
              env_hash="${env_hash}-${var}-${!var}"
            fi
          done
        fi

        # Generate final cache key
        cache_key="${os_key}"
        [ -n "$prefix_key" ] && cache_key="${cache_key}-${prefix_key}"
        [ -n "$type_key" ] && cache_key="${cache_key}-${type_key}"
        [ -n "$files_hash" ] && cache_key="${cache_key}-${files_hash}"
        [ -n "$env_hash" ] && cache_key="${cache_key}-${env_hash}"

        echo "cache-key=${cache_key}" >> $GITHUB_OUTPUT

        # Process cache paths
        IFS=',' read -ra PATHS <<< "$CACHE_PATHS"
        cache_paths=""
        for path in "${PATHS[@]}"; do
          cache_paths="${cache_paths}${path}\n"
        done
        echo "cache-paths=${cache_paths}" >> $GITHUB_OUTPUT

    - id: cache
      uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830 # v4.3.0
      with:
        path: ${{ steps.prepare.outputs.cache-paths }}
        key: ${{ steps.prepare.outputs.cache-key }}
        restore-keys: ${{ inputs.restore-keys }}
