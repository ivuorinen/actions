---
# yaml-language-server: $schema=https://json.schemastore.org/github-action.json
name: Docker Publish to GitHub Packages
description: 'Publishes a Docker image to GitHub Packages with advanced security and reliability features.'
author: 'Ismo Vuorinen'

branding:
  icon: 'package'
  color: 'blue'

inputs:
  image-name:
    description: 'The name of the Docker image to publish. Defaults to the repository name.'
    required: false
  tags:
    description: 'Comma-separated list of tags for the Docker image.'
    required: true
  platforms:
    description: 'Platforms to publish (comma-separated). Defaults to amd64 and arm64.'
    required: false
    default: 'linux/amd64,linux/arm64'
  registry:
    description: 'GitHub Container Registry URL'
    required: false
    default: 'ghcr.io'
  token:
    description: 'GitHub token with package write permissions'
    required: false
    default: ${{ github.token }}
  provenance:
    description: 'Enable SLSA provenance generation'
    required: false
    default: 'true'
  sbom:
    description: 'Generate Software Bill of Materials'
    required: false
    default: 'true'
  max-retries:
    description: 'Maximum number of retry attempts for publishing'
    required: false
    default: '3'
  retry-delay:
    description: 'Delay in seconds between retries'
    required: false
    default: '10'
  buildx-version:
    description: 'Specific Docker Buildx version to use'
    required: false
    default: 'latest'
  cache-mode:
    description: 'Cache mode for build layers (min, max, or inline)'
    required: false
    default: 'max'
  auto-detect-platforms:
    description: 'Automatically detect and build for all available platforms'
    required: false
    default: 'false'
  scan-image:
    description: 'Scan published image for vulnerabilities'
    required: false
    default: 'true'
  sign-image:
    description: 'Sign the published image with cosign'
    required: false
    default: 'true'
  parallel-builds:
    description: 'Number of parallel platform builds (0 for auto)'
    required: false
    default: '0'
  verbose:
    description: 'Enable verbose logging'
    required: false
    default: 'false'

outputs:
  image-name:
    description: 'Full image name including registry'
    value: ${{ steps.metadata.outputs.full-name }}
  digest:
    description: 'The digest of the published image'
    value: ${{ steps.publish.outputs.digest }}
  tags:
    description: 'List of published tags'
    value: ${{ steps.metadata.outputs.tags }}
  provenance:
    description: 'SLSA provenance attestation'
    value: ${{ steps.publish.outputs.provenance }}
  sbom:
    description: 'SBOM document location'
    value: ${{ steps.publish.outputs.sbom }}
  scan-results:
    description: 'Vulnerability scan results'
    value: ${{ steps.scan.outputs.results }}
  platform-matrix:
    description: 'Build status per platform'
    value: ${{ steps.publish.outputs.platform-matrix }}
  build-time:
    description: 'Total build time in seconds'
    value: ${{ steps.publish.outputs.build-time }}

runs:
  using: composite
  steps:
    - name: Validate Inputs
      id: validate
      shell: bash
      run: |
        set -euo pipefail

        # Validate image name format
        if [ -n "${{ inputs.image-name }}" ]; then
          if ! [[ "${{ inputs.image-name }}" =~ ^[a-z0-9]+(?:[._-][a-z0-9]+)*$ ]]; then
            echo "::error::Invalid image name format"
            exit 1
          fi
        fi

        # Validate tags
        IFS=',' read -ra TAGS <<< "${{ inputs.tags }}"
        for tag in "${TAGS[@]}"; do
          if ! [[ "$tag" =~ ^(v?[0-9]+\.[0-9]+\.[0-9]+(-[\w.]+)?(\+[\w.]+)?|latest|[a-zA-Z][-a-zA-Z0-9._]{0,127})$ ]]; then
            echo "::error::Invalid tag format: $tag"
            exit 1
          fi
        done

        # Validate platforms
        IFS=',' read -ra PLATFORMS <<< "${{ inputs.platforms }}"
        for platform in "${PLATFORMS[@]}"; do
          if ! [[ "$platform" =~ ^linux/(amd64|arm64|arm/v7|arm/v6|386|ppc64le|s390x)$ ]]; then
            echo "::error::Invalid platform: $platform"
            exit 1
          fi
        done

    - name: Set up QEMU
      uses: docker/setup-qemu-action@29109295f81e9208d7d86ff1c6c12d2833863392 # v3.6.0
      with:
        platforms: ${{ inputs.platforms }}

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@e468171a9de216ec08956ac3ada2f0791b6bd435 # v3.11.1
      with:
        version: ${{ inputs.buildx-version }}
        platforms: ${{ inputs.platforms }}
        buildkitd-flags: --debug
        driver-opts: |
          network=host
          image=moby/buildkit:${{ inputs.buildx-version }}

    - name: Prepare Metadata
      id: metadata
      shell: bash
      run: |
        set -euo pipefail

        # Determine image name
        if [ -z "${{ inputs.image-name }}" ]; then
          image_name=$(basename $GITHUB_REPOSITORY)
        else
          image_name="${{ inputs.image-name }}"
        fi

        # Output image name for reuse
        echo "image-name=${image_name}" >> $GITHUB_OUTPUT

        # Construct full image name with registry
        full_name="${{ inputs.registry }}/${{ github.repository_owner }}/${image_name}"
        echo "full-name=${full_name}" >> $GITHUB_OUTPUT

        # Process tags
        processed_tags=""
        IFS=',' read -ra TAGS <<< "${{ inputs.tags }}"
        for tag in "${TAGS[@]}"; do
          processed_tags="${processed_tags}${full_name}:${tag},"
        done
        processed_tags=${processed_tags%,}
        echo "tags=${processed_tags}" >> $GITHUB_OUTPUT

    - name: Log in to GitHub Container Registry
      uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef # v3.6.0
      with:
        registry: ${{ inputs.registry }}
        username: ${{ github.actor }}
        password: ${{ inputs.token }}

    - name: Set up Cosign
      if: inputs.provenance == 'true' || inputs.sign-image == 'true'
      uses: sigstore/cosign-installer@d7543c93d881b35a8faa02e8e3605f69b7a1ce62 # v3.10.0

    - name: Detect Available Platforms
      id: detect-platforms
      if: inputs.auto-detect-platforms == 'true'
      shell: bash
      run: |
        set -euo pipefail

        # Get available platforms from buildx
        available_platforms=$(docker buildx ls | grep -o 'linux/[^ ]*' | sort -u | tr '\n' ',' | sed 's/,$//')

        if [ -n "$available_platforms" ]; then
          echo "platforms=${available_platforms}" >> $GITHUB_OUTPUT
          echo "Detected platforms: ${available_platforms}"
        else
          echo "platforms=${{ inputs.platforms }}" >> $GITHUB_OUTPUT
          echo "Using default platforms: ${{ inputs.platforms }}"
        fi

    - name: Publish Image
      id: publish
      shell: bash
      env:
        DOCKER_BUILDKIT: 1
      run: |
        set -euo pipefail

        # Normalize repository owner to lowercase for GHCR compatibility
        REPO_OWNER_LOWER=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
        export REPO_OWNER_LOWER

        # Track build start time
        build_start=$(date +%s)

        # Determine platforms
        if [ "${{ inputs.auto-detect-platforms }}" == "true" ] && [ -n "${{ steps.detect-platforms.outputs.platforms }}" ]; then
          platforms="${{ steps.detect-platforms.outputs.platforms }}"
        else
          platforms="${{ inputs.platforms }}"
        fi

        # Initialize platform matrix tracking
        platform_matrix="{}"

        # Prepare verbose flag
        verbose_flag=""
        if [ "${{ inputs.verbose }}" == "true" ]; then
          verbose_flag="--progress=plain"
        fi

        attempt=1
        max_attempts=${{ inputs.max-retries }}

        while [ $attempt -le $max_attempts ]; do
          echo "Publishing attempt $attempt of $max_attempts"

          # Prepare tag arguments from comma-separated tags
          tag_args=""
          IFS=',' read -ra TAGS <<< "${{ steps.metadata.outputs.tags }}"
          for tag in "${TAGS[@]}"; do
            tag=$(echo "$tag" | xargs) # trim whitespace
            tag_args="$tag_args --tag $tag"
          done

          if docker buildx build \
            --platform=${platforms} \
            $tag_args \
            --push \
            --cache-from type=registry,ref=${{ inputs.registry }}/${{ env.REPO_OWNER_LOWER }}/cache:buildcache \
            --cache-to type=registry,ref=${{ inputs.registry }}/${{ env.REPO_OWNER_LOWER }}/cache:buildcache,mode=${{ inputs.cache-mode }} \
            ${{ inputs.provenance == 'true' && '--provenance=true' || '' }} \
            ${{ inputs.sbom == 'true' && '--sbom=true' || '' }} \
            ${verbose_flag} \
            --metadata-file=/tmp/build-metadata.json \
            --label "org.opencontainers.image.source=${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}" \
            --label "org.opencontainers.image.created=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" \
            --label "org.opencontainers.image.revision=${GITHUB_SHA}" \
            --label "org.opencontainers.image.version=${{ inputs.tags }}" \
            .; then

            # Get image digest
            IFS=',' read -ra TAGS <<< "${{ inputs.tags }}"
            digest=$(docker buildx imagetools inspect ${{ steps.metadata.outputs.full-name }}:${TAGS[0]} --raw | jq -r '.digest // "unknown"' || echo "unknown")
            echo "digest=${digest}" >> $GITHUB_OUTPUT

            # Calculate build time
            build_end=$(date +%s)
            build_time=$((build_end - build_start))
            echo "build-time=${build_time}" >> $GITHUB_OUTPUT

            # Build platform matrix
            IFS=',' read -ra PLATFORM_ARRAY <<< "${platforms}"
            platform_matrix="{"
            for p in "${PLATFORM_ARRAY[@]}"; do
              platform_matrix="${platform_matrix}\"${p}\":\"success\","
            done
            platform_matrix="${platform_matrix%,}}"
            echo "platform-matrix=${platform_matrix}" >> $GITHUB_OUTPUT

            # Generate attestations if enabled
            if [[ "${{ inputs.provenance }}" == "true" ]]; then
              echo "provenance=true" >> $GITHUB_OUTPUT
            fi

            if [[ "${{ inputs.sbom }}" == "true" ]]; then
              sbom_path="${{ inputs.registry }}/${{ github.repository_owner }}/${{ steps.metadata.outputs.image-name }}.sbom"
              echo "sbom=${sbom_path}" >> $GITHUB_OUTPUT
            fi

            break
          fi

          attempt=$((attempt + 1))
          if [ $attempt -le $max_attempts ]; then
            echo "Publish failed, waiting ${{ inputs.retry-delay }} seconds before retry..."
            sleep ${{ inputs.retry-delay }}
          else
            echo "::error::Publishing failed after $max_attempts attempts"
            exit 1
          fi
        done

    - name: Scan Published Image
      id: scan
      if: inputs.scan-image == 'true'
      shell: bash
      run: |
        set -euo pipefail

        # Install Trivy
        wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
        echo "deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee -a /etc/apt/sources.list.d/trivy.list
        sudo apt-get update && sudo apt-get install -y trivy

        # Get first tag for scanning
        IFS=',' read -ra TAGS <<< "${{ inputs.tags }}"

        # Scan the published image
        trivy image \
          --severity HIGH,CRITICAL \
          --format json \
          --output /tmp/scan-results.json \
          ${{ steps.metadata.outputs.full-name }}:${TAGS[0]}

        # Output results
        scan_results=$(cat /tmp/scan-results.json | jq -c '.')
        echo "results=${scan_results}" >> $GITHUB_OUTPUT

        # Check for critical vulnerabilities
        critical_count=$(cat /tmp/scan-results.json | jq '.Results[].Vulnerabilities[] | select(.Severity == "CRITICAL") | .VulnerabilityID' | wc -l)
        if [ "$critical_count" -gt 0 ]; then
          echo "::warning::Found $critical_count critical vulnerabilities in published image"
        fi

    - name: Sign Published Image
      id: sign
      if: inputs.sign-image == 'true'
      shell: bash
      run: |
        set -euo pipefail

        # Sign all tags
        IFS=',' read -ra TAGS <<< "${{ inputs.tags }}"
        for tag in "${TAGS[@]}"; do
          echo "Signing ${{ steps.metadata.outputs.full-name }}:${tag}"

          # Using keyless signing with OIDC
          export COSIGN_EXPERIMENTAL=1
          cosign sign --yes ${{ steps.metadata.outputs.full-name }}:${tag}
        done

        echo "signature=signed" >> $GITHUB_OUTPUT

    - name: Verify Publication
      id: verify
      shell: bash
      run: |
        set -euo pipefail

        # Verify image existence and accessibility
        IFS=',' read -ra TAGS <<< "${{ inputs.tags }}"
        for tag in "${TAGS[@]}"; do
          if ! docker buildx imagetools inspect ${{ steps.metadata.outputs.full-name }}:${tag} >/dev/null 2>&1; then
            echo "::error::Published image not found: $tag"
            exit 1
          fi
        done

        # Determine platforms to verify
        if [ "${{ inputs.auto-detect-platforms }}" == "true" ] && [ -n "${{ steps.detect-platforms.outputs.platforms }}" ]; then
          platforms="${{ steps.detect-platforms.outputs.platforms }}"
        else
          platforms="${{ inputs.platforms }}"
        fi

        # Verify platforms
        IFS=',' read -ra PLATFORMS <<< "${platforms}"
        for platform in "${PLATFORMS[@]}"; do
          if ! docker buildx imagetools inspect ${{ steps.metadata.outputs.full-name }}:${TAGS[0]} | grep -q "$platform"; then
            echo "::warning::Platform $platform not found in published image"
          fi
        done

        # Verify signature if signing was enabled
        if [ "${{ inputs.sign-image }}" == "true" ]; then
          export COSIGN_EXPERIMENTAL=1
          for tag in "${TAGS[@]}"; do
            if ! cosign verify --certificate-identity-regexp ".*" --certificate-oidc-issuer-regexp ".*" ${{ steps.metadata.outputs.full-name }}:${tag} >/dev/null 2>&1; then
              echo "::warning::Could not verify signature for ${tag}"
            fi
          done
        fi

    - name: Clean up
      if: always()
      shell: bash
      run: |-
        set -euo pipefail

        # Remove temporary files and cleanup Docker cache
        docker buildx prune -f --keep-storage=10GB

        # Logout from registry
        docker logout ${{ inputs.registry }}
